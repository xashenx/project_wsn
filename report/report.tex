%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% University/School Laboratory Report
% LaTeX Template
% Version 3.0 (4/2/13)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original author:
% Linux and Unix Users Group at Virginia Tech Wiki 
% (https://vtluug.org/wiki/Example_LaTeX_chem_lab_report)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass{article}

\usepackage{graphicx} % Required for the inclusion of images
\usepackage{listings} % Required for insertion of code
\usepackage{amssymb}
\setlength\parindent{0pt} % Removes all indentation from paragraphs
\usepackage[usenames,dvipsnames]{color} % Required for custom colors
\renewcommand{\labelenumi}{\alph{enumi}.} % Make numbering in the enumerate environment by letter rather than number (e.g. section 6)
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\definecolor{mysilver}{gray}{0.85}
%\usepackage{times} % Uncomment to use the Times New Roman font
\usepackage{graphicx, array, blindtext}
\usepackage{float}
\restylefloat{figure}
\usepackage{multirow}

%----------------------------------------------------------------------------------------
%	CODE INCLUSION CONFIGURATION
%----------------------------------------------------------------------------------------

\definecolor{MyDarkGreen}{rgb}{0.0,0.4,0.0} % This is the color used for comments
\lstloadlanguages{C,C++} % load C syntax

\lstset{ %
  backgroundcolor=\color{mysilver},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=single,                    % adds a frame around the code
  keywordstyle=\color{blue},       % keyword style
  language=C,					   % the language of the code
  morekeywords={*,...},            % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  stepnumber=200,    
  firstnumber=1,
  numberfirstline=false
  %numberstyle=\tiny\color{gray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  %stepnumber=2,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,                       % sets default tabsize to 2 spaces
  title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}

%----------------------------------------------------------------------------------------
%	DOCUMENT INFORMATION
%----------------------------------------------------------------------------------------

%----------------------------------------------------------------------------------------
%	TITLE PAGE
%----------------------------------------------------------------------------------------

\title{
     \begin{figure}[ht]
       \centering
       \includegraphics[angle=-90, keepaspectratio=true, width=8cm]{images/logo}
     \end{figure}
\vspace{1in}
\textmd{\textbf{Load Balanced Routing Protocol}}\\
\textmd{\normalsize{Wireless Sensor Networks}}\\
%\normalsize\vspace{0.1in}\small{Due\ on\ \hmwkDueDate}\\
%\vspace{0.1in}\large{\textit{\hmwkClassInstructor\ \hmwkClassTime}}
\vspace{3in}
}
\author{\textbf{Fabrizio Zeni} \\ \small{153465}}
\date{} % Insert date here if you want it to appear below your name

\begin{document}

\maketitle % Insert the title, author and date
\thispagestyle{empty}
\begin{center}
\begin{tabular}{l r}
\end{tabular}
\end{center}
\clearpage
% If you wish to include an abstract, uncomment the lines below
\thispagestyle{empty}
\begin{abstract}
This report describes the project developed for the wireless sensor networks laboratory.
It starts from the project specifications and continues through the implementation choices.
It ends with the experimental results and their analysis.
\end{abstract}
\tableofcontents
\clearpage
%----------------------------------------------------------------------------------------
%	SECTION 1 - PROJECT SPECIFICATION
%----------------------------------------------------------------------------------------
\pagenumbering{arabic}
\bigskip
\bigskip
\bigskip
\section{Introduction}
\subsection{Project Specifications}
\label{sec:projspec}
The project specifications ask to implement a \emph{Load Balanced Routing Protocol} (LBRP) over \textit{TOSSIM} which is capable to route the data traffic through a wireless sensor network up to a node called \textbf{sink}, which is responsible of the data collection.
Each node is responsible to mantain its own "routing table", which in this case is represented by a list of \emph{parent nodes} as the next-hop node toward the sink. To balance the traffic among the parents, the node has to check the amount of forwarded message of each parent and verify, for each pair of parents, the following formula: \begin{center}$0 \leq msg_{p_{a}} - msg_{p_{b}} \leq 1$\end{center}
where $msg_{p_{i}}$ are the messages forwarded to the parent $p_{i}$ of the node.
\\The picture below (Figure~\ref{fig:LBRPexample}), shows how the LBRP should act on a simple network.
		\begin{figure}[H]
			\begin{center}
				\includegraphics[scale=.6]{graphs/newlink_1_routing}
				\caption{Example of load balancing routing}
				\label{fig:LBRPexample}
			\end{center}
		\end{figure}
\clearpage

%----------------------------------------------------------------------------------------
%	SECTION 2 - PROJECT IMPLEMENTATION
%----------------------------------------------------------------------------------------

\section{Project Implementation}
	\subsection{File structure}
	In the project root are present the following items:
	\begin{itemize}
		\item \emph{Tree} directory, which contains the implementation of the application using the Tree-based routing
		\item \emph{Graph} directory, which contains the implementation of the application using the LBRP
		\item \emph{results} directory, which contains the results obtained from some simulations
		\item \emph{test}\footnote{test bash script: described in Section ~\ref{sec:bash} at page ~\pageref{sec:bash}} bash script, used to perform sequential tests
		\item \emph{statistics.awk} and \emph{mean.awk}, two AWK script used to manage the data gathering through simulations
	\end{itemize}
	The Tree directory contains almost the same files of the Graph on, so let's have a look to the latter:
	\begin{itemize}
		\item *.py, python scripts to run simulation on specific scenarios
		\item *.out, topologies for specific scenarios
		\item \emph{DataToNetwork.nc}, interface which provides communication from the data layer to the network layer
		\item \emph{DataLayerC.nc}, data layer configuration
		\item \emph{DataLayerP.nc}, data layer component
		\item \emph{DataMsg.h}, header file for the data layer
		\item \emph{Debug Makefile Reliable Remove}, makefiles that will be better described in the next subsection
		\item \emph{NetworkLayerC.nc}, network layer configuration
		\item \emph{NetworkLayerP.nc}, network layer component
		\item \emph{NetworkToData.nc}, interface which provides communication from the network layer to the data layer
		\item \emph{RoutingMsg.h}, header file for the network layer
	\end{itemize}
	\subsection{How to run the project}
		\label{sec:howto}
Looking at the project root, the code is contained mainly in two directories: \textbf{Graph} and \textbf{Tree}. The implementation of the LBRP is in the Graph one, while the other contain the \textit{single-parent} implementation, which was used to make some comparison over the developed protocol. The application is \textit{modular}, in the sense that from the same code is possible to compile any subversion of the application. That is made possible through some \emph{preprocessor conditional branches} inside the code (\textit{\#ifdef keyword}), which are triggered when the compilation is done using a specific makefile. These are the makefiles defined so far:
		\begin{itemize}
		  \item Makefile - the default one, which compiles the standard version of the application
		  \item Reliable - which compiles the reliable 1-1 communications version
		  \item Remove - which compiles the Cascade Parent Removal version
		  \item Debug - which compiles the debug version of the program
		\end{itemize}

If the version to compile is the standard one, it will be suffies to run "\textit{make micaz sim}", else the command to input will be "\textit{make -f \textbf{makefile\_name} micaz sim}", where \textbf{makefile\_name} is the makefile of the version to compile.\\
\\Then to run the compiled program, one of the python scripts has to be chosen. 
		\begin{itemize}
		  \item 25.py - this script will execute the script over a topology generated through the topology generator contained in tinyos, with 25 nodes
		  \item 49.py - as the previous, the topology was generated, but this time it has 49 nodes
		  \item newlink.py - executes the script over an ad-hoc scenario, built to check the response of the protocol
		  \item test.py - as for the previous, executes over an another ad-hoc scenario
		  \item stable.py - executes the script on a toplogy of 8 nodes with a stable topology and a good connectivity
		\end{itemize}
To run the simulation type "\textit{python name\_of\_script}" and the simulation will begin.
To simplify this procedure, I prepared a \emph{bash script}, which is described in section~\ref{sec:bash}.
\clearpage
	\subsection{Protocol description}
The difference between a tree routing protocol and the one implemented, can be seen in the following example.
		\begin{figure}[H]
			\begin{center}
				\includegraphics[scale=.4]{graphs/stable_0_start}
				\caption{Stable scenario start}
				\label{fig:stableStart}
			\end{center}
		\end{figure}
This is a simple topology, which will be used for some tests, with 3 layer\footnote{layer X: means that the node/group of nodes can reach the sink in X hops} 1 nodes (1,2,3), 2 layer 2 nodes (4,5) and a chain of two nodes as descendants of node 5.
		\begin{table}[H]
			\centering
			\begin{tabular}{cc}
				\includegraphics[scale=.4]{graphs/stable_1_routing}&\includegraphics[scale=.4]{graphs/stable_1tree_routing}\\
			\end{tabular}
			\caption{Comparison: Tree and LBRP}
			\label{tab:comparisonProto}
		\end{table}
The differences of the two protocols can be easily seen in Table~\ref{tab:comparisonProto}, in fact the tree protocol builds the routing chain by selecting the lower ID parent among candidates with the best cost, while LBRP chooses all those candidates and balance the traffic following the formula written in Section~\ref{sec:projspec} at page ~\pageref{sec:projspec}.
\clearpage
	\subsubsection{LBRP structures}
The first thing to take into consideration when coding a multiple-parent routing is to fix a structure to mantain the information. I defined the following structure:
\lstinputlisting[firstline=62,lastline=81,language=C++,caption=Parent Structure of LBRP]{../Graph/RoutingMsg.h}
Actually the paremeters used are the ones out of any preprocessor guards: \textit{id} and \textit{forwarded}, which makes the structure as simple and straightforward as possible. The other parameters were supposed to be used for further developments of the protocols, but by now they are just coded in the header file.
\\The RoutingMsg/Beacon looks like the structure:
\lstinputlisting[firstline=40,lastline=49,language=C++,caption=Routing message]{../Graph/RoutingMsg.h}
The id of the sender is just a redundant information, because it can be retrieved by calling \textit{AMPacket.source} over the received message, while we need a \textit{sequence number} to organize the beacons with an ordering dictate by the sink.
\clearpage
	\subsubsection{LBRP flow}
		\begin{figure}[H]
			\begin{center}
				\includegraphics[scale=.43]{images/activity}
				\caption{Activity Diagram of the LBRP}
				\label{fig:activityLBRP}
			\end{center}
		\end{figure}
The protocol flow is described in Figure~\ref{fig:activityLBRP}. An important thing that should be noticed, is that a node will broadcast a routing message, (almost) only when its current cost to the sink is somehow changed. This avoids the genearation of traffic which should not give any benefit to the network.
The flow start from the receipt of a RoutingMsg, then the flow continues only if the \textit{sequence number} is greater or equal to the current stored by the receiving node. In both cases the next branch checks the cost, lets look first to the case when the sequence number is equal to the current (which means that a a message with that seq\_no has already reached the node). 
\\\textbf{Sequence number equal to the current}
\\If a message with a \emph{lower} cost reaches the node, then there is a new better path to the sink and then the structure is \textit{reset} (because it might contain parents with the previous cost). I will describe the rest of the flow from the reset when dealing with the other major branch regarding the sequence number lower than the current.
\\If the cost is \emph{equal} to the current and the sender is not a parent, then the node is added to the parents and the new parent is signalled to the DataLayer, because it is the newest parent, and it is likely that some messages should be forwarded to it, in order to achieve the same load of older parents. There is no need to have a branch for the case in which the sender is a parent because it will not add any new information and is a wast of time and resources.
\\If the cost is \emph{greater} than the current and the sender is a parent, then there is another branch checking the number of parents in the structure. If more than one parent are present, then the sender is just removed, because there is at least another parent that can reach the sink with the current cost. Otherwise an update of the current cost is performed and a broadcast of a RoutingMsg is scheduled to advertise the neighbors of the change.
\\\textbf{Sequence number lower than the current}
\\If the cost is \emph{equal} to the current and the sender is not a parent, then the node is added to the parents, an update of the sequence number is performed and a broadcast of a RoutingMsg is scheduled. The broadcast can be skipped, because no changes are made when this case occurs, but I just kept this procedure because the broadcast is made for the other the case of the branching.
\\If the current cost is \emph{greater} or lower than the current, the structured is reset. The reset is performed even if the incoming cost is greater, on the assumption that if a message with a greater cost has reached the node before the ones with the same cost, probably there were some change on the network and so to mantain a path to the sink, a parent with a greater cost in this case is acceptable. Then there is a step that depends on whether the sender is a parent or not. If it is a \emph{parent}, the algorithm takes the past forwarded message count to the node and set that for the new position of the parent (head of the structure), \emph{otherwise} the messages are set to 0 and the flow can go on. An update of the cost is performed, the new parent is signalled to the data layer, the current sequence number is updated and finally a broadcast is scheduled.
\clearpage
	\subsection{Implemented Features}
	
During the development of the project, I inserted into the project several features (modes), which alter the behaviour of the protocol. The major difference stands in the reliability of the communication, in fact there is the baseline versione which has estEffort 1-1 communications, while I developed another version with Reliable 1-1. I decided to develop several version in order to run them over different topologies and compare their results.

		\subsubsection{Best-Effort 1-1}
	
This was the requested mode for the developed project, which substancially does not take care of any retransmission in a best effort trasmission flavour. So that any trasmission to a parent will be counted, without taking into consideration its result. As said in the section~\ref{sec:howto}, to compile this version it would be suffice to type "make micaz sim"

		\subsubsection{Reliable 1-1}
	
Thanks to the use of acks and their managment, this version work over a reliable 1-1 channel. In this case, only successful communication are counted for each parent. The differences in the code are almost only in the DataLayer module.

		\subsubsection{CPR - Cascade Parent Removal}
	
The Cascade Parent Removal is a feature which can be used by the Reliable 1-1 version. It comes from the idea that when the communications to a parent are unsuccessfull for a given number of sequential attempts, it ends up in the assumption that such parent is no more reachable (might be dead, moved away, etc). But as the name might suggest, this feature does a bit more, infact whenever a parent is removed following the procedure before and that parent was the only one the node have, a NO\_PARENT\_MSG is broadcasted. Each node that will receive such message, will check if the send is among its parents and in that case the sender will be removed from the parents. This procedure will be repeated until  a node which has a "backup" route is found (or even a node which is not the son of the sender of the NO\_PARENT\_MSG), and this explains the term \textit{cascade}.
Furthermore, CPR implements a \textit{recovery} procedure, so that when a NO\_PARENT\_MSG reaches a node that has a "safe" route, that node will schedule the broadcast of a routing message, so that the orphan node(s) (a cascade might have happened) will eventually rebuild a path to the sink.

	\subsection{Not-Yet-Implemented Features}
Here I list some features that I started to implement, but by now are not yet completed. They are listed just for explain why in the code there might be some reference to structures, methods,etc that might seem not connected to the goals of the project.

		\subsubsection{Alive Messages}
	
The Alive procedure was one of the first features on which I started to work at the begining of the development. It can be said that it was the \emph{parent of CPR}. However, Alive was rather much complex than CPR, it involved both Data and NetworkLayer, and even a specific \textit{timer} was used. The NetworkLayer was \textit{constantly} looking at the \emph{state} of any parents, so that when a communication from a parent is received, the state of such parent is set to ALIVE, on the contrary whenever the alive timer is triggered, the state of each parent is decremented. For each value of the state of a parent, a behavior is codified, such that:
		\begin{itemize}
			\item 3 (ALIVE): the parent is alive, the normal behavior is allowed
			\item 2 : tollerance level, the behavior will be  kept as normal even in this stage
			\item 1 : the absence of parent communications is rather suspicious, stop data communications, send an AliveMsg
			\item 0 (DEAD): the parent is marked as dead, it can be removed and/or substituted
		\end{itemize}
An Alive Message, was a message with a minimal dummy payload, an integer containing the nodeId of the sender, for which a acks is explicitly requested. In the original idea, the Alive mechaninsm was planned to be applied to all version, so that even with the Best-Effort a way to substitute broken/bad links would be available.

		\subsubsection{Other Balancing Metrics}
		\label{sec:balancingMetrics}
The balancing of the load over a count mantained locally by each node, could be improved somehow. That was my tought, so I started thinking what can be exploited to have a better view of the congestion of parent nodes. I reached two possibilities: \textbf{buffer usage} and \textbf{traffic} of parent. The first idea comes from the fact that if we can retrieve the buffer usage of each parent, it would be nice to send the traffic to the one with the \emph{highest buffer availability}. Moreover I looked over the buffer usage and it turned out that with my settings for the timers that \emph{send messages} (from the buffer) and \emph{generate messages} (insert in the buffer), which are respectively set to \textit{5s} and \textit{10,5s}, if we use a time $\tau_i$, where $\tau_{i+1}-\tau_{i}=5s$, a buffer of size \emph{n}, will be filled at time $\tau_n$ when having two descendants (e.g. two children or a child and a grandchild). So a tuning over the buffer might be a good idea.
\\ The traffic metric, looks over the forwarded messaged FROM each parent. This is much more general than the previous, but can anyway give the flavour of the congestion of a node.
\\Both the metrics are quite easy to implement, but the problem consists in the rate at which the refresh of that information is provvided to the children. In fact if it is too large (e.g. beaconing period) the information could became rather old and the balancing cannot be such effective, on the other hand if the refresh happens too often it could introduce too much overhead into the network.

		\subsubsection{Rebuild Messages}
			\label{sec:rebuildMessages}
This was meant to be an \textit{extension} of CPR, where a \textbf{request of rebuild} (ROR\_MSG) would be routed to the sink in order to ask for a new \emph{beacon}. For the \textit{rebuild period} I thought at two possibilities:
			\begin{itemize}
				\item Single rebuild beacon, the sink sends a single rebuild beacon for each request
				\item Adaptive beacon, inspired to the one of \emph{CTP\footnote{Collection Tree Protocol: http://www.tinyos.net/tinyos-2.x/doc/html/tep123.html}} (which is itself inspired to \emph{Trickle\footnote{Trickle Algorithm: http://www.cs.berkeley.edu/~pal/pubs/trickle-nsdi04.pdf}}), but applied to the receipt of rebuild messages, so that whenever a ROR\_MSG is received by the sink the beacong period is set to a minimum, while at each activation of the beaconing timer, the period is doubled up to the max value.
			\end{itemize}
		
	\subsection{Tools}
	
		\subsubsection{Bash script}
		\label{sec:bash}
		
I wrote a bash script to make easier the job of running series of tests and perform data analysis. By typing "./test help", the script returns a small documentation. The script call format is "./test test\_mode number\_of\_tests number\_of\_nodes name\_of\_test python\_script\_name [compile]" where \textit{test\_mode} can be:
\begin{itemize}
	\item normal, for running the best-effort version of the project
	\item rel, for running the reliable version of the project
	\item remove, for running the CPR version of the project
	\item tree, for running the best-effort tree-single-parent version
	\item reltree, for running the reliable tree-single-parent version
\end{itemize}
The \textit{python\_script\_name} is the name of the python script used for the simulations and could be one of those named in Section~\ref{sec:howto}.

		\subsubsection{AWK}

The AWK\footnote{AWK wikipage: https://en.wikipedia.org/wiki/AWK} language was used in order to work over the data gathered by the simulations and make some stastistics over them.

		\subsubsection{DOT}
		
I used DOT\footnote{DOT wikipage: http://en.wikipedia.org/wiki/DOT\_\%28graph\_description\_language\%29} language to give a graphical description of the network graphs
\clearpage
%----------------------------------------------------------------------------------------
%	SECTION 3 - Experimental results
%----------------------------------------------------------------------------------------

\section{Experimental Results}
	In this section I will show the result of a series of sequential test ran for all version of the project. Each subsection contains the results of a specific scenario, whose detailed description can be found in \emph{Appendix A}. In order to do a comparison, for each testng session I took the forwarded message to each parent from each node (as suggested by the project specifications) and the number of arrived packet for each node, which can rate the reliability of the tested version. Anyway, please note that only some results are reported here, but the complete list of results can be seen in the subdirectory \textit{results} of the project.
\\In this section the names of the tests are shortened to fit into tables, so that:
	\begin{itemize}
		\item \textbf{betree}, for the best-effort 1-1 version of the tree procotol
		\item \textbf{belbrp}, for the best-effort 1-1 version of the LBRP
		\item \textbf{reltree}, for the reliable 1-1 version of the tree protocol
		\item \textbf{rellbrp}, for the reliable 1-1 version of the LBRP
		\item \textbf{cpr}, for the CPR version of the LBRP
	\end{itemize}
The tests were done with the parameters given in the project specification, so the \emph{send period} was set to 5sec, while the \textbf{beacon period} was set to 5minutes. Moreover these were some parameters set by me:
	\begin{itemize}
		\item \textbf{data generation period}, the period at which each node generates its own data to send, set to 10.5s (something more of the double of the \textit{send period}, to avoid that the buffer will become full too early.
		\item \textbf{length of the simulation}, set to 20 minutes (=1200000ms), so that we will be able to see about 4 beacons, and keep a reasonable time of simulation
		\item \textbf{number of tests}, for the smaller topologies (newlink,test,stable) for each protocol were done 200 sequential simulations, while for the topologies made of 25 and 49 nodes the simulations were 100
	\end{itemize}
The choises of the \textit{simulation length} and the \textit{number of tests} were driven by the need to keep the "real" time of each simulation "brach" as much reasonable as possibile. The problem was due to the fact that the time spent for each simulation was almost proportional to the number of nodes, so on the 49 topology 1 simulation took about 3'39'', which implies that the "pack" of simulations (for one protocol) took 6 hours and 5 minutes. Then simply multiply it for 5 (the developed version of the protocols) and we get that for getting the data for the topology, it was needed 1 day, 6 hours and 25 minutes.
	\subsection{Newlink Results}
In this scenario, the connectivity in the network is subject to some changes, infact 3 links are removed in the early phase of the simulation (30\% of the simulation time), and two links are added respectively at 55\% and 60\%.

		\begin{table}[H]
			\centering
			\begin{tabular}{cc}
				\includegraphics[scale=.35]{graphs/newlink_4_add2}&\includegraphics[scale=.35]{graphs/newlink_4tree_add2}\\
			\end{tabular}
			\caption{Newlink Final stage}
			\label{tab:comparisonNewlink}
		\end{table}
		
When the network reaches its final configuration, the different behavior between the Tree protocol and the LBRP can be easily seen from the Table~\ref{tab:newF2}:
		\begin{table}[H]
			\begin{center}
			    \begin{tabular}{|c|c|c|c|c|c|c|c|c|}
				    \hline
				    \multirow{2}{*}{\textbf{TEST NAME}} & \multicolumn{8}{c|}{\textbf{FORWARDED MESSAGES TO}} \\ \cline{2-9}
					& 0 & 1 & 2 & 3 & 4 & 5 & 6 & TOT \\ \hline
				    betree & 54.94 & - & - & 118.58 & - & - & $\sim$1 & 174.41 \\ \hline
				    belbrp & 54.82 & - & - & 59.22 & - & - & 47.88 & 161.92 \\ \hline
				    reltree & 9.30 & - & - & 103.92 & - & - & $\sim$1 & 113.98 \\ \hline
   				    rellbrp & 9.22 & - & - & 59.76 & - & - & 45.85 & 114.83 \\ \hline
				    cpr & 9.33 & - & - & 96.08 & - & - & 32.72 & 138.13 \\ \hline
			    \end{tabular}
			\end{center}	
			\caption{Messages forwarded by node 2}
			\label{tab:newF2}
		\end{table}
It can be seen that both versions of the tree protocol report only an average of forwarded messages to 6 less to 1, probably due to some temporary problem inside the network. The majority of messages are forwarded to 3, because it is the lower ID parent candidate. On the other hand, when the link between 2 and 6 came up, 6 is added as parent and in order to balance the load, the messages are sent almost to 6 in order to bring the two parents to the same level of load.
		\begin{table}[H]
			\begin{center}
			    \begin{tabular}{|c|c|c|c|c|c|}
				    \hline
				    \multirow{2}{*}{\textbf{MSG FROM}} & \multicolumn{5}{c|}{\textbf{TEST NAME}} \\ \cline{2-6}
					& betree & belbrp & reltree & rellbrp & cpr \\ \hline
					2 & 13.06 & 11.48 & 22.08 & 19.48 & 30.48 \\ \hline
			    \end{tabular}
			\end{center}	
			\caption{Messages arrived to sink from 2}
			\label{tab:newA2}
		\end{table}
The table above (Table~\ref{tab:newA2}) shows the number of messages originally sent by 2 which reached the sink. The reliable versions got a way better deliver rate if compared to the forwarding messages report in Table~\ref{tab:newF2}. In particular, the CPR version did a really good job by having more than the double of best-effort versions and one third more than reltree and rellbrp.
	\subsection{Test Results}
Here the same 3 links of Newlink are removed in the early phase, while a new node 7 is added in the late phase of the simulation (75\%). The node is configured to have two links one to the sink and one to the periphery of the network (node 5), which should force the network to reconstruct the routing schema. Moreover the link between between 1 and the sink has a really low gain, which makes the communication chain till the sink a bit problematic.
		\begin{figure}[H]
			\begin{center}
				\includegraphics[scale=.4]{graphs/test_3_new}
				\caption{Final configuration of Test scenario}
				\label{fig:testFinal}
			\end{center}
		\end{figure}
Even in this case, could be interesting to see the forwarded messages from 2:
		\begin{table}[H]
			\begin{center}
			    \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|}
				    \hline
				    \multirow{2}{*}{\textbf{TEST NAME}} & \multicolumn{9}{c|}{\textbf{FORWARDED MESSAGES TO}} \\ \cline{2-10}
					& 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & TOT \\ \hline
				    betree & 57.42 & - & - & 116.14 & - & 1.56 & - & - & 175.13 \\ \hline
				    belbrp & 52.95 & - & - & 105.03 & - & 2.44 & - & - & 160.41 \\ \hline
				    reltree & 10.52 & - & - & 107.33 & - & 1.23 & - & - & 119.07 \\ \hline
   				    rellbrp & 10.57 & - & - & 109.49 & - & 2.86 & - & - & 122.92 \\ \hline
				    cpr & 10.63 & - & - & 55.70 & - & 4.8 & - & - & 71.14 \\ \hline
			    \end{tabular}
			\end{center}	
			\caption{Messages forwarded by node 2}
			\label{tab:testF2}
		\end{table}
In the table above, the gap of \textit{total forwardings} between cpr and the others is quite big, and that need some investigation over the topology. Anyway with a bit of debug it turned out, that the loosy gain between 1 and the sink, which was the gateway for all the network until the arrival of 7, was the cause of the trigger of the cascade parent removal, which starting from 1 stopped all the network until the next successful beacon. Another thing that can be said from the Table~\ref{tab:testF2} is that the tests with LBRP and its variants seems to be faster to adapt to the topology changes. 
	\subsection{Stable Results}
This test was done on a stable topology with a good connectivity.
		\begin{table}[H]
			\centering
			\begin{tabular}{cc}
				\includegraphics[scale=.35]{graphs/stable_1_routing}&\includegraphics[scale=.35]{graphs/stable_1tree_routing}\\
			\end{tabular}
			\caption{Stable Routing}
			\label{tab:comparisonStable}
		\end{table}
This time the interesting part of the test resides in the node 5, because, as can be seen in Table~\ref{tab:comparisonStable}, the forwarding results of the node 5 can show the differences between the routing protocols and because it is the head of a node chain (5 <--> 6 <--> 7), which can show how the protocols behave on chain of nodes.
		\begin{table}[H]
			\begin{center}
			    \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|}
				    \hline
				    \multirow{2}{*}{\textbf{TEST NAME}} & \multicolumn{9}{c|}{\textbf{FORWARDED MESSAGES TO}} \\ \cline{2-10}
					& 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & TOT \\ \hline
				    betree & - & 183.01 & - & 1.99 & - & - & - & - & 185 \\ \hline
				    belbrp & - & 61.19 & 61.91 & 61.90 & - & - & - & - & 185 \\ \hline
				    reltree & - & 156.97 & - & 1.73 & - & - & - & - & 158.74 \\ \hline
   				    rellbrp & - & 52.27 & 52.70 & 52.34 & - & - & - & - & 157.31 \\ \hline
				    cpr & - & 50.77 & 50.51 & 49.49 & - & - & - & - & 150.86 \\ \hline
			    \end{tabular}
			\end{center}	
			\caption{Messages forwarded by node 5}
			\label{tab:stableF5}
		\end{table}
The two besteffort versions (and even reltree and rellbrp) show the different behavior of the tree protocol and LBRP, in fact as Table~\ref{tab:comparisonStable} depicts, the tree protocol forwards almost everything to node 1 (with a small amount which is forwarded to node 3 because of a temporary choice of 3 as parent), while LBRP divides the traffic between 1,2 and 3.
		\begin{table}[H]
			\begin{center}
			    \begin{tabular}{|c|c|c|c|c|c|}
				    \hline
				    \multirow{2}{*}{\textbf{MSG FROM}} & \multicolumn{5}{c|}{\textbf{TEST NAME}} \\ \cline{2-6}
					& betree & belbrp & reltree & rellbrp & cpr \\ \hline
					5 & 21.92 & 16.41 & 9.25 & 18.20 & 16.86 \\ \hline
					6 & 47.17 & 42.91 & 36.38 & 42.91 & 50.08 \\ \hline
					7 & 46.85 & 40.10 & 35.32 & 37.98 & 45.52 \\ \hline
			    \end{tabular}
			\end{center}	
			\caption{Messages arrived to sink from 5,6,7}
			\label{tab:stableArrivals}
		\end{table}
From Table~\ref{tab:stableArrivals} a couple of thing can be observed. The performances of the besteffort version are higher than the standard reliable ones (reltree,rellbrp), and are almost the same of CPR. This can be explained by the good connectivity, so that the probability that a message is sent correctly is high, which implies that the besteffort approach can land a good number of deliveries to the sink, while whenever a fail happen in the reliable versions (in the send itself or in the ack delivery), it turns out in an overhead which is a waste in such scenario. Furthermore, the fact that the less messages from the head node (5) are received than the ones from its descendants, can be due to the buffer problem, which was brefly took into consideration in Section~\ref{sec:balancingMetrics} at page ~\pageref{sec:balancingMetrics}.
	\subsection{Random topologies Results}
The LBRP seems to work as expected when the topology is randomly generated and the number of nodes larger than in the previous scenarios. The 25 and 49 nodes generated topologies gives the flavour of how the protocol works. Take for instance the forwardings of the node 22 of the test made over the 25 nodes scenario (\textbf{NOTE}: the results are cut to show only some of the meaningfull data, the complete results can be seen on the file \textit{forwarded\_22.csv}):
		
		\begin{table}[H]
			\begin{center}
			    \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|}
				    \hline
				    \multirow{2}{*}{\textbf{TEST}} & \multicolumn{11}{c|}{\textbf{FORWARDED MESSAGES TO}} \\ \cline{2-12}
					& 0 & 1 & 2 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11\\ \hline
				    betree & \begin{footnotesize}-\end{footnotesize} & \begin{footnotesize}35.62\end{footnotesize} & \begin{footnotesize}27.31\end{footnotesize} & \begin{footnotesize}20.67\end{footnotesize} & \begin{footnotesize}-\end{footnotesize} & \begin{footnotesize}4.37\end{footnotesize} & \begin{footnotesize}-\end{footnotesize} & \begin{footnotesize}-\end{footnotesize} & \begin{footnotesize}-\end{footnotesize} & \begin{footnotesize}-\end{footnotesize} & \begin{footnotesize}-\end{footnotesize}\\ \hline
				    belbrp & \begin{footnotesize}-\end{footnotesize} & \begin{footnotesize}4.06\end{footnotesize} & \begin{footnotesize}5.28\end{footnotesize} & \begin{footnotesize}6.46\end{footnotesize} & \begin{footnotesize}2.42\end{footnotesize} & \begin{footnotesize}7.32\end{footnotesize} & \begin{footnotesize}1.76\end{footnotesize} & \begin{footnotesize}3.54\end{footnotesize} & \begin{footnotesize}3.85\end{footnotesize} & \begin{footnotesize}8.38\end{footnotesize} & \begin{footnotesize}5.56\end{footnotesize}\\ \hline
				    reltree & \begin{footnotesize}-\end{footnotesize} & \begin{footnotesize}16.23\end{footnotesize} & \begin{footnotesize}10.33\end{footnotesize} & \begin{footnotesize}12.59\end{footnotesize} & \begin{footnotesize}-\end{footnotesize} & \begin{footnotesize}3.65\end{footnotesize} & \begin{footnotesize}-\end{footnotesize} & \begin{footnotesize}-\end{footnotesize} & \begin{footnotesize}-\end{footnotesize} & \begin{footnotesize}-\end{footnotesize} & \begin{footnotesize}-\end{footnotesize}\\ \hline
   				    rellbrp & \begin{footnotesize}-\end{footnotesize} & \begin{footnotesize}2.74\end{footnotesize} & \begin{footnotesize}2.91\end{footnotesize} & \begin{footnotesize}3.87\end{footnotesize} & \begin{footnotesize}1.12\end{footnotesize} & \begin{footnotesize}4.86\end{footnotesize} & \begin{footnotesize}2.04\end{footnotesize} & \begin{footnotesize}1.53\end{footnotesize} & \begin{footnotesize}2.02\end{footnotesize} & \begin{footnotesize}4.81\end{footnotesize} & \begin{footnotesize}3.39\end{footnotesize}\\ \hline
				    cpr & \begin{footnotesize}-\end{footnotesize} & \begin{footnotesize}5.02\end{footnotesize} & \begin{footnotesize}2.56\end{footnotesize} & \begin{footnotesize}2.47\end{footnotesize} & \begin{footnotesize}$\sim$1\end{footnotesize} & \begin{footnotesize}9.67\end{footnotesize} & \begin{footnotesize}4.35\end{footnotesize} & \begin{footnotesize}3.4\end{footnotesize} & \begin{footnotesize}2.22\end{footnotesize} & \begin{footnotesize}5.08\end{footnotesize} & \begin{footnotesize}4.36\end{footnotesize}\\ \hline
			    \end{tabular}
			\end{center}	
			\caption{Messages forwarded by node 22}
			\label{tab:25F22P1}
		\end{table}	
		\begin{table}[H]
			\begin{center}
			    \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|}
				    \hline
				    \multirow{2}{*}{\textbf{TEST}} & \multicolumn{10}{c|}{\textbf{FORWARDED MESSAGES TO}} \\ \cline{2-11}
					& 12 & 13 & 15 & 16 & 17 &  18 & 20 & 21 & 23 & TOT \\ \hline
				    betree & \begin{footnotesize}-\end{footnotesize} & \begin{footnotesize}-\end{footnotesize} & \begin{footnotesize}-\end{footnotesize} & \begin{footnotesize}-\end{footnotesize} & \begin{footnotesize}-\end{footnotesize} & \begin{footnotesize}-\end{footnotesize} & \begin{footnotesize}-\end{footnotesize} & \begin{footnotesize}-\end{footnotesize} & \begin{footnotesize}-\end{footnotesize} & \begin{footnotesize}89.01\end{footnotesize} \\ \hline
				    belbrp & \begin{footnotesize}1.42\end{footnotesize} & \begin{footnotesize}-\end{footnotesize} & \begin{footnotesize}3.16\end{footnotesize} & \begin{footnotesize}7.24\end{footnotesize} & \begin{footnotesize}7.21\end{footnotesize} & \begin{footnotesize}7.28\end{footnotesize} & \begin{footnotesize}6.86\end{footnotesize} & \begin{footnotesize}7.25\end{footnotesize} & \begin{footnotesize}-\end{footnotesize} & \begin{footnotesize}89.31\end{footnotesize} \\ \hline
				    reltree & \begin{footnotesize}-\end{footnotesize} & \begin{footnotesize}-\end{footnotesize} & \begin{footnotesize}-\end{footnotesize} & \begin{footnotesize}-\end{footnotesize} & \begin{footnotesize}-\end{footnotesize} & \begin{footnotesize}-\end{footnotesize} & \begin{footnotesize}-\end{footnotesize} & \begin{footnotesize}-\end{footnotesize} & \begin{footnotesize}-\end{footnotesize} & \begin{footnotesize}44.15\end{footnotesize} \\ \hline
   				    rellbrp & \begin{footnotesize}1.64\end{footnotesize} & \begin{footnotesize}-\end{footnotesize} & \begin{footnotesize}1.53\end{footnotesize} & \begin{footnotesize}4.04\end{footnotesize} & \begin{footnotesize}4.17\end{footnotesize} & \begin{footnotesize}4.31\end{footnotesize} & \begin{footnotesize}5.11\end{footnotesize} & \begin{footnotesize}4.28\end{footnotesize} & \begin{footnotesize}-\end{footnotesize} & \begin{footnotesize}54.72\end{footnotesize} \\ \hline
				    cpr & \begin{footnotesize}4.64\end{footnotesize} & \begin{footnotesize}2.29\end{footnotesize} & \begin{footnotesize}4.33\end{footnotesize} & \begin{footnotesize}11.03\end{footnotesize} & \begin{footnotesize}9.10\end{footnotesize} & \begin{footnotesize}7.53\end{footnotesize} & \begin{footnotesize}4.48\end{footnotesize} & \begin{footnotesize}5.44\end{footnotesize} & \begin{footnotesize}3.11\end{footnotesize} & \begin{footnotesize}97.14\end{footnotesize} \\ \hline
			    \end{tabular}
			\end{center}	
			\caption{Messages forwarded by node 22}
			\label{tab:25F22P2}
		\end{table}		
		
The links of the generated topology are not strong, which lead to the loss of routing packets which implies that the routing protocols sometimes acts as non-optimal. Nevertheless, the tests of the tree protocols choose as main parent the node 1, followed by 2,4 and 6, while the rest of nodes does not take any forwarding from 22. From the tree results, we can infere that 1,2,4,6 have almost the \textit{same cost} to reach the sink, but the beacons reach the node 22 in the inverse order, so that first 6 is chosen, then 4, then 2 and finally 1 as the \textit{smallest id}. Nevertheless when using LBRP 1,2,4 are not chosen so often, that is because the number of parent is fixed (10) until they are removed from the structure (because they got an increased cost or a better way is found), their slots are used.
\begin{lstlisting}[caption=Routing debug messages of node 22 with rellbrp,label=lst:22]
DEBUG (22): NEW	SEQNO	21	COST	2{0}
DEBUG (22): ADD	PARENT	5	SAME	2{0}
DEBUG (22): ADD	PARENT	4	SAME	2{0}
DEBUG (22): ADD	PARENT	18	SAME	2{0}
DEBUG (22): ADD	PARENT	10	SAME	2{0}
DEBUG (22): ADD	PARENT	2	SAME	2{0}
DEBUG (22): ADD	PARENT	11	SAME	2{0}
DEBUG (22): ADD	PARENT	17	SAME	2{0}
DEBUG (22): ADD	PARENT	9	SAME	2{0}
DEBUG (22): ADD	PARENT	16	SAME	2{0}
DEBUG (22): NEW	SEQNO	16	COST	2{9}
DEBUG (22): NEW	SEQNO	1	COST	2{0}
DEBUG (22): REMOVE	PARENT	2	COST	3>2
DEBUG (22): REMOVE	PARENT	18	COST	3>2
DEBUG (22): REMOVE	PARENT	17	COST	3>2
DEBUG (22): REMOVE	PARENT	11	COST	3>2
DEBUG (22): REMOVE	PARENT	10	COST	3>2
DEBUG (22): REMOVE	PARENT	21	COST	4>2
\end{lstlisting}
In the Listing~\ref{lst:22} can be seen the routing debug messages of the node 22 on a rellbrp simulation loop. After the first beacon the parent structure contains {2,4,5,9,10,11,16,17,18,21}, then the maximum number of parents its reached. The second beacon comes from 16, which is already a parent of 22, so no problems come from that and for that application cycle there are no change in the structure. The third and last beacon are forwarded by 1, which is not a parent and because it comes with a cost equal to the current and the structure is full, the last parent (16 in this case) is substituted by 2. During this cycle, the network had some problem which is highlighted by the fact that 6 of the previous parents are removed by the structure due to their increased cost to reach the sink. The CPR version\footnote{if interested the log is on \textit{results/25/routing\_22}} is even more interesting and give some information on the network, infact a lot of NO\_PARENT\_MESSAGES are sent and the network are not able to reach a stable routing. So in general, it can be said that CPR introduces some overhead in this scenario, which is due to the fact that the links are not good and the delivery of the beacons can be seen as a matter of "luck". In cases like these (and in real world development), would be better to have a link quality estimator, which can help in the choice of parents by adding a knowledge of the "goodness" of the link along to their cost.
		\begin{table}[H]
			\begin{center}
			    \begin{tabular}{|c|c|c|c|c|c|}
				    \hline
				    %\multirow{2}{*}{\textbf{MSG FROM}} & \multicolumn{5}{c|}{\textbf{TEST NAME}} \\ \cline{2-6}
				    TEST NAME & MIN & MAX & AVG & VAR & ST.DEV\\ \hline
					betree & 3 & 34 & 15.87 & 40.27 & 6.35\\ \hline
					belbrp & 6 & 23 & 13.54 & 15.53 & 3.94\\ \hline
					reltree & 0 & 73 & 10.24 & 111.24 & 10.55\\ \hline
					rellbrp & 0 & 30 & 7.90 & 31.17 & 5.58\\ \hline
					cpr & 2 & 29 & 13.93 & 42.29 & 6.50\\ \hline
			    \end{tabular}
			\end{center}	
			\caption{Messages arrived to sink from 22}
			\label{tab:25Arrivals22}
		\end{table}

Anyway from the Table~\ref{tab:25Arrivals22} it can be seen that even if some overhead was introduced by the CPR algorithm, the performance of the protocol were near to the one of the best-effort tree and by looking at the results of other nodes, in the majority of the cases the delivered messages are even more than the ones done in the other versions.


%\\In cases like these (and in real world development), would be better to have a link quality estimator to choose 
%\\la rete non ha una connettività stabile, il che porta alla perdita di pacchetti di routing che inficiano le scelte dei protocolli. Tuttavia possiamo notare che i test sui protoccoli a tree, scelgono come predominante il nodo 1 come padre, seguito da 2 e 4. Le versioni di LBRP, come poteva essere auspicabile, scelgono 1 e 6 come padri più stabili. Per quanto riguarda belbrp e rellbrp viene scelto anche 0.
%\textbf{NON E' PROPRIO COSI! È IL FATTO DEI NO PARENT MESSAGES CHE PORTA AD AVERE "CASUAL" PARENTS}il fatto che CPR abbia scelto 0 come proprio padre può essere spiegato dal fatto che oltre ai semplici beacons generati dalla sink, CPR prevede anche un messaggio di "recovery" da parte dei neighbors che ricevono un NO\_PARENT\_MSG, il che può aver fortuitamente dato luogo all'arrivo di uno di questi messaggi di recovery al nodo 24 e quindi alla scelta di 0 come parent.
%----------------------------------------------------------------------------------------
%	SECTION 4
%----------------------------------------------------------------------------------------

\section{Conclusions}
In general the performances of LBRP was good and the algorithm performs as expected. Sometimes the overhead, introduced by the need of using a specific structure and the routines needed for the load balancing, were affecting the numbers of forwarding w.r.t. the tree protocol, but the differences was almost negligible. Even if some tweak is still needed, the CPR was working well, but when I will have some time I will implement the \textit{rebuild messages}\footnote{Sec~\ref{sec:rebuildMessages} at page~\pageref{sec:rebuildMessages}} feature to see its influence on the routing process.
However, as shown for the bigger and random topologies, the quality of the channel and link have a huge impact on the performances of the algorithms e on their choices.I think that in order to obtain better results, would be necessary to integrate some kind of lin quality estimator (RSSI,LQI,ETX), so that a metric on the communication environment can help to choose whether a neighbor can be good parent or not. Without that, the routing protocols might be subjected to the delivery of beacons from not-so-reliable links, which can compromise the operating principle of the network. Moreover, the introduction of a data aggregation scheme could be an interesting choice to enhance the performance on the data layer, which might prevent the buffer congestion problem. For instance, the whole current buffer can be forwarded, so that at each trigger of the send timer, the buffer is emptied. However it should be better analysed, because in some scenario it could lead to "bottle-neck" problem on some nodes.
\clearpage
%----------------------------------------------------------------------------------------
%	APPENDIXES
%----------------------------------------------------------------------------------------
\section{Appendixes}
\subsection{Appendix A: Scenarios in-depth look}
\subsubsection{Newlink}
	\bigskip
	\bigskip
	\begin{table}[H]
		\centering
		\begin{tabular}{*{2}{m{0.48\textwidth}}}
			\hline
			\small This is the configuration at the start&\begin{center}\includegraphics[scale=.4]{graphs/newlink_0_start}\end{center}\\
			\hline
			\begin{center}\includegraphics[scale=.4]{graphs/newlink_1_routing}\end{center}&\begin{center}\includegraphics[scale=.4]{graphs/newlink_1tree_routing}\end{center}\\
			\multicolumn{2}{p{12cm}}{\small After the first beacon, the difference between the Tree protocol and the LBRP is that in the first the node 6 will have just 1 as parent, while in the latter 3 will be chosen as another parent, because both 1 and 3 reaches the sink through 1 hop}\\
			\hline
			\small At the 30\% of the simulation the red links will be removed, so the network will reconstruct in the way depicted in the figure on the right, so that a long chain will be used to deliver messages&\begin{center}\includegraphics[scale=.4]{graphs/newlink_2_remove}\end{center}\\
			\hline
		\end{tabular}
		\label{tab:newlinkIndepthP1}
	\end{table}
	\begin{center}
	\small \textit{continues on the next page ...}
	\end{center}
	\clearpage
	\begin{table}[H]
		\centering
		\begin{tabular}{*{2}{m{0.48\textwidth}}}
			\hline
			\small At 55\% of the simulation, a link between 3 and 1 is added, so both tree and LBRP will choose 1 as the new parent for 3 because of the minor cost than 6.&\begin{center}\includegraphics[scale=.4]{graphs/newlink_3_add1}\end{center}\\
			\hline
			\begin{center}\includegraphics[scale=.4]{graphs/newlink_4_add2}\end{center}&\begin{center}\includegraphics[scale=.4]{graphs/newlink_4tree_add2}\end{center}\\
			\multicolumn{2}{p{12cm}}{\small At 60\% of the simulation, another link is added, this time between 2 and 6. That link will be chosen by LBRP based versions, to add 6 as parent of 2 (along with 3), while it will be almost ignored by Tree versions}\\
			\hline
		\end{tabular}
		\label{tab:newlinkIndepthP2}
	\end{table}
\subsubsection{Test}
	The first three steps are equal to the Newlink ones, that can be seen on the previous page.
	\begin{table}[H]
		\centering
		\begin{tabular}{*{2}{m{0.48\textwidth}}}
			\hline
			\small At 75\% of the simulation a new node (7) is added with links to the sink and to 5. This will force the network to choose a new configuration, because the introduction of 7, bring a new path with a reduced cost to 5 and 2&\begin{center}\includegraphics[scale=.4]{graphs/test_3_new}\end{center}\\
			\hline
		\end{tabular}
		\label{tab:testIndepthP1}
	\end{table}
\subsubsection{Stable}
	\begin{table}[H]
		\centering
		\begin{tabular}{*{2}{m{0.48\textwidth}}}
			\hline
			\small This topology is characterised by a stable configuration and links with a good gain. &\begin{center}\includegraphics[scale=.4]{graphs/stable_0_start}\end{center}\\
			\hline
			\begin{center}\includegraphics[scale=.4]{graphs/stable_1_routing}\end{center}&\begin{center}\includegraphics[scale=.4]{graphs/stable_1tree_routing}\end{center}\\
			\multicolumn{2}{p{12cm}}{\small After the first beacon, the difference between the Tree protocol and the LBRP is that the "second layer" nodes will route their traffic to 1 when using a Tree versions, while by using LBRP the traffic will be split between 1,2,3}\\
			\hline
		\end{tabular}
		\label{tab:stableIndepth}
	\end{table}
\clearpage

%----------------------------------------------------------------------------------------
%	BIBLIOGRAPHY
%----------------------------------------------------------------------------------------

\bibliographystyle{unsrt}

\bibliography{sample}

%----------------------------------------------------------------------------------------


\end{document}
